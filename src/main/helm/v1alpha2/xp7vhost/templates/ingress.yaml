# Create ingress
{{- if .Values.vhost.spec.options.ingress }}
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: {{ .Values.vhost.name }}
  namespace: {{ .Values.vhost.namespace }}
  labels:
    {{ $.Values.labelKeys.managed }}: true
    {{- with $.Values.defaultLabels }}
    {{- toYaml . | nindent 4 }}
    {{- end }}
  annotations:
    kubernetes.io/ingress.class: nginx
    nginx.ingress.kubernetes.io/proxy-body-size: {{ .Values.vhost.spec.options.ingressMaxBodySize }}
    ingress.kubernetes.io/rewrite-target: /
    {{- if .Values.vhost.spec.options.dnsRecord }}
    enonic.cloud/dns.hostname: {{ .Values.vhost.spec.host }}
    enonic.cloud/dns.heritage: {{ list "heritage=ec-operator,id=" .Values.vhost.uid | join "" }}
    {{- end }}
    {{- if .Values.vhost.spec.options.cdn }}
    enonic.cloud/dns.cdn: "true"
    {{- end }}
    {{- if .Values.vhost.spec.options.statusCake }}
    monitor.stakater.com/enabled: "true"
    {{- end }}
    {{- if .Values.vhost.issuer }}
    cert-manager.io/cluster-issuer: {{ .Values.vhost.issuer }}
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    {{- end }}

    {{- if .Values.vhost.spec.options.ipWhitelist }}
    nginx.ingress.kubernetes.io/whitelist-source-range: {{ quote .Values.vhost.spec.options.ipWhitelist }}
    {{- end }}

    {{- if .Values.extensions.ingress.DDOS.enabled }}
    nginx.ingress.kubernetes.io/limit-connections: {{ .Values.extensions.ingress.DDOS.limitConnections }}
    nginx.ingress.kubernetes.io/limit-rpm: {{ .Values.extensions.ingress.DDOS.limitRpm }}
    {{- end }}

    {{- if .Values.extensions.ingress.stickySession.enabled }}
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/session-cookie-name: {{ .Values.vhost.name }}
    {{- end }}

    {{- if .Values.vhost.spec.options.caching }}
    nginx.ingress.kubernetes.io/proxy-buffering: "on"
    {{- end }}

    # https://www.nginx.com/blog/nginx-caching-guide/
    nginx.ingress.kubernetes.io/configuration-snippet: |
      # Extra config
      {{- if .Values.vhost.spec.options.caching }}
      proxy_cache static-cache;
      proxy_cache_use_stale error timeout updating http_404 http_500 http_502 http_503 http_504;
      proxy_cache_key $proxy_host$request_uri$cookie_jessionid;

      # Allow to bypass cache with Pragma header
      proxy_cache_bypass $http_pragma;

      # Send cache status header back
      add_header X-Cache-Status $upstream_cache_status;
      {{- end }}
      {{- if .Values.extensions.linkerd.enabled }}
      proxy_set_header l5d-dst-override $service_name.$namespace.svc.cluster.local:$service_port;
      grpc_set_header l5d-dst-override $service_name.$namespace.svc.cluster.local:$service_port;
      {{- end }}

spec:
  rules:
    - host: {{ .Values.vhost.spec.host }}
      http:
        paths:
          {{- range $mapping := .Values.vhost.spec.mappings }}
          - backend:
              serviceName: {{ $mapping.nodeGroup }}
              servicePort: 8080
            path: {{ $mapping.source }}
          {{- end }}
  {{- if .Values.vhost.spec.certificate }}
  tls:
    - hosts:
        - {{ .Values.vhost.spec.host }}
      secretName: {{ if .Values.vhost.issuer }}{{ .Values.vhost.name }}{{ else }}{{ .Values.vhost.spec.certificate.identifier }}{{ end }}
  {{- end }}
---
{{- end }}